<!DOCTYPE html>
<html>

<head lang="en">
  <meta charset="UTF-8">
  <title>GPX Map Matching Explorer & MapLibre GL - Powered by Geoapify</title>

  <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <style>html,
body {
    width: 100%;
    height: 100%;
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
}

body {
    display: flex;
    flex-direction: column;
}

.demo-container {
    flex: 1;
    max-height: 100%;
    display: flex;
    flex-direction: row;
}

.sidebar {
    width: 350px;
    padding: 20px;
    background: #f8f9fa;
    border-left: 1px solid #e9ecef;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
}

.sidebar h2 {
    margin: 0 0 15px 0;
    color: #333;
    font-size: 1.5em;
    text-align: center;
}

.sidebar p {
    margin: 0 0 30px 0;
    color: #666;
    line-height: 1.5;
    text-align: center;
}

.sidebar h3 {
    margin: 20px 0 10px 0;
    color: #333;
    font-size: 1.1em;
}

#map {
    flex: 1;
    min-height: 400px;
}

.button {
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 10px;
}

.button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.upload-button {
    background: #28a745;
    color: white;
    width: 100%;
}

.upload-button:hover {
    background: #218838;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);
}

.match-button {
    background: #007bff;
    color: white;
    width: 100%;
}

.match-button:hover:not(:disabled) {
    background: #0056b3;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 123, 255, 0.3);
}

.clear-button {
    background: #dc3545;
    color: white;
    width: 100%;
}

.clear-button:hover {
    background: #c82333;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(220, 53, 69, 0.3);
}

.button:active {
    transform: translateY(0);
}

/* Upload section styles */
.upload-section {
    margin-bottom: 20px;
}

.file-info {
    margin-top: 10px;
    padding: 10px;
    background: #e9ecef;
    border-radius: 6px;
    font-size: 14px;
    color: #495057;
}

.file-info.success {
    background: #d4edda;
    color: #155724;
}

.file-info.error {
    background: #f8d7da;
    color: #721c24;
}

/* Travel mode styles */
.mode-section {
    margin-bottom: 20px;
}

.travel-modes {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.mode-option {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 10px;
    border: 2px solid #e9ecef;
    border-radius: 6px;
    transition: all 0.2s ease;
}

.mode-option:hover {
    background: #f8f9fa;
    border-color: #dee2e6;
}

.mode-option input[type="radio"] {
    margin-right: 10px;
}

.mode-option span {
    display: flex;
    align-items: center;
    gap: 8px;
}

.mode-option span i {
    font-size: 16px;
    width: 20px;
    text-align: center;
}

.mode-option input[type="radio"]:checked + span {
    color: #007bff;
    font-weight: 600;
}

.mode-option:has(input[type="radio"]:checked) {
    border-color: #007bff;
    background: #e7f3ff;
}

/* Summary section styles */
.summary-info {
    margin-top: 20px;
    padding: 15px;
    background: #e9ecef;
    border-radius: 6px;
}

.summary-info h3 {
    margin: 0 0 10px 0;
    color: #333;
    font-size: 1.1em;
}

.summary-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 14px;
}

.summary-item:last-child {
    margin-bottom: 0;
}

.summary-label {
    color: #666;
}

.summary-value {
    color: #333;
    font-weight: 600;
}

/* Dialog styles */
.dialog-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.dialog {
    background: white;
    border-radius: 10px;
    padding: 30px;
    min-width: 400px;
    max-width: 500px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}

.dialog h3 {
    margin: 0 0 20px 0;
    color: #333;
    text-align: center;
}

.dialog p {
    margin: 0 0 20px 0;
    color: #666;
    line-height: 1.5;
}

.form-buttons {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 30px;
}

.form-buttons button {
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

#error-ok-button {
    background: #007bff;
    color: white;
}

#error-ok-button:hover {
    background: #0056b3;
}

/* Loading indicator styles */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1001;
}

.loading-spinner {
    text-align: center;
    background: white;
    padding: 30px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.spinner {
    width: 40px;
    height: 40px;
    border: 4px solid #f3f3f3;
    border-top: 4px solid #007bff;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 20px;
}

.loading-spinner p {
    margin: 0;
    color: #666;
    font-size: 14px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.hidden {
    display: none;
}

/* Map layer styles */
.maplibregl-popup {
    max-width: 300px;
}

.maplibregl-popup-content {
    padding: 10px;
    border-radius: 6px;
}

.popup-title {
    font-weight: 600;
    color: #333;
    margin-bottom: 5px;
}

.popup-info {
    font-size: 12px;
    color: #666;
    margin-bottom: 3px;
}

.popup-info strong {
    color: #333;
}

/* Download button styles */
.download-section {
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid #dee2e6;
}

.download-button {
    background: #6c757d;
    color: white;
    width: 100%;
}

.download-button:hover:not(:disabled) {
    background: #5a6268;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(108, 117, 125, 0.3);
}

/* Responsive design */
@media (max-width: 768px) {
    .demo-container {
        flex-direction: column;
    }
    
    .sidebar {
        width: 100%;
        max-height: 300px;
        border-left: none;
        border-bottom: 1px solid #e9ecef;
    }
    
    .sidebar h2 {
        font-size: 1.2em;
    }
    
    .sidebar p {
        font-size: 14px;
    }
    
    .dialog {
        min-width: 300px;
        margin: 20px;
    }
} </style>
</head>

<body>
  <div class="demo-container">
    <div id="map"></div>
    <div class="sidebar">
      <h2>GPX Map Matching</h2>
      <p>Upload a GPX file to see the original GPS trace and its matched route</p>
      
      <div class="upload-section">
        <input type="file" id="gpx-file-input" accept=".gpx,.xml" style="display: none;">
        <button class="button upload-button" id="upload-button">Upload GPX File</button>
        <div id="file-info" class="file-info hidden"></div>
      </div>
      
      <div class="mode-section">
        <h3>Travel Mode</h3>
        <div class="travel-modes">
          <label class="mode-option">
            <input type="radio" name="travel-mode" value="walk" checked>
            <span><i class="fas fa-walking"></i> Walk</span>
          </label>
          <label class="mode-option">
            <input type="radio" name="travel-mode" value="drive">
            <span><i class="fas fa-car"></i> Drive</span>
          </label>
          <label class="mode-option">
            <input type="radio" name="travel-mode" value="bicycle">
            <span><i class="fas fa-bicycle"></i> Bicycle</span>
          </label>
        </div>
      </div>
      
      <button class="button match-button" id="match-button" disabled>Match to Roads</button>
      <button class="button clear-button" id="clear-all-button">Clear All</button>
      
      <div id="summary-info" class="summary-info hidden">
        <h3>Summary</h3>
        <div id="summary-content"></div>
      </div>
      
      <div id="download-section" class="download-section hidden">
        <h3>Download Matched Route</h3>
        <button class="button download-button" id="download-geojson">Download GeoJSON</button>
        <button class="button download-button" id="download-gpx">Download GPX</button>
      </div>
    </div>
  </div>

  <!-- Loading indicator -->
  <div id="loading-indicator" class="loading-overlay hidden">
    <div class="loading-spinner">
      <div class="spinner"></div>
      <p>Processing GPX file and matching to roads...</p>
    </div>
  </div>

  <!-- Error dialog -->
  <div id="error-dialog" class="dialog-overlay hidden">
    <div class="dialog">
      <h3>Error</h3>
      <p id="error-message"></p>
      <div class="form-buttons">
        <button type="button" id="error-ok-button">OK</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/togeojson@0.16.0/togeojson.js"></script>
  <script src="https://unpkg.com/togpx@0.5.4/togpx.js"></script>
  <script src="https://unpkg.com/simplify-js@1.2.4/simplify.js"></script>
  <script type="module">class MapMatchingAPI {
    constructor(apiKey) {
        this.apiKey = apiKey;
        this.baseUrl = 'https://api.geoapify.com/v1/mapmatching';
    }

    async performMapMatching(gpxData, travelMode) {
        if (!gpxData || gpxData.length === 0) {
            throw new Error('No GPS data available. Please upload a GPX file first.');
        }

        const requestData = {
            mode: travelMode,
            waypoints: gpxData.map(point => {
                const data = {
                    location: point.location
                };
                
                if (point.timestamp) {
                    data.timestamp = point.timestamp;
                }
                
                return data;
            })
        };

        const response = await fetch(`${this.baseUrl}?apiKey=${this.apiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestData)
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `API request failed with status ${response.status}`);
        }

        const matchingResult = await response.json();
        
        if (!matchingResult.features || matchingResult.features.length === 0) {
            throw new Error('No matching results returned from API');
        }

        return matchingResult;
    }
}

if (typeof window !== 'undefined') {
    window.MapMatchingAPI = MapMatchingAPI;
} </script>
  <script type="module">class FileUtils {
    constructor(maxPoints = 1000) {
        this.maxPoints = maxPoints;
    }

    parseGpxFile(gpxContent) {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(gpxContent, 'application/xml');
        
        const parserError = xmlDoc.querySelector('parsererror');
        if (parserError) {
            throw new Error('Invalid XML format');
        }

        const geoJson = toGeoJSON.gpx(xmlDoc);
        
        if (!geoJson.features || geoJson.features.length === 0) {
            throw new Error('No track data found in GPX file');
        }

        const coordinates = [];
        const timestamps = [];
        
        geoJson.features.forEach(feature => {
            if (feature.geometry.type === 'LineString') {
                feature.geometry.coordinates.forEach((coord, index) => {
                    coordinates.push([coord[0], coord[1]]);
                    
                    if (feature.properties && feature.properties.coordTimes && feature.properties.coordTimes[index]) {
                        timestamps.push(feature.properties.coordTimes[index]);
                    }
                });
            }
        });

        if (coordinates.length === 0) {
            throw new Error('No valid coordinates found in GPX file');
        }

        return this.processCoordinates(coordinates, timestamps);
    }

    processCoordinates(coordinates, timestamps) {
        let finalCoordinates = coordinates;
        let finalTimestamps = timestamps;
        let simplificationApplied = false;
        const originalCount = coordinates.length;

        if (coordinates.length > this.maxPoints) {
            const result = this.simplifyPolyline(coordinates, timestamps, this.maxPoints);
            finalCoordinates = result.coordinates;
            finalTimestamps = result.timestamps;
            simplificationApplied = true;
            
            console.log(`Route simplified from ${originalCount} to ${finalCoordinates.length} points`);
        }

        const gpxData = finalCoordinates.map((coord, index) => ({
            location: coord,
            timestamp: finalTimestamps[index] || undefined
        }));

        return {
            gpxData,
            coordinates: finalCoordinates,
            simplificationApplied,
            originalCount
        };
    }

    simplifyPolyline(coordinates, timestamps, maxPoints) {
        if (coordinates.length <= maxPoints) {
            return { coordinates, timestamps };
        }
        
        // Combine coordinates and timestamps into point objects
        const points = coordinates.map(([lng, lat], i) => ({
            x: lng,
            y: lat,
            t: timestamps[i] || null
        }));
        
        // Use simplify-js with progressive tolerance values
        let simplified = points;
        for (const tolerance of [0.00001, 0.0001, 0.001, 0.01, 0.1]) {
            if (simplified.length <= maxPoints) break;
            simplified = simplify(simplified, tolerance, true);
        }
        
        // If still exceeds maxPoints, keep every Nth point
        if (simplified.length > maxPoints) {
            const skipFactor = Math.ceil(simplified.length / maxPoints);
            const fallbackPoints = [simplified[0]]; // Always include first point
            
            for (let i = skipFactor; i < simplified.length - 1; i += skipFactor) {
                fallbackPoints.push(simplified[i]);
            }
            
            // Always include last point if not already included
            const lastPoint = simplified[simplified.length - 1];
            if (fallbackPoints[fallbackPoints.length - 1] !== lastPoint) {
                fallbackPoints.push(lastPoint);
            }
            
            simplified = fallbackPoints;
        }
        
        return {
            coordinates: simplified.map(pt => [pt.x, pt.y]),
            timestamps: simplified.map(pt => pt.t)
        };
    }

    calculateHaversineDistance(coord1, coord2) {
        const R = 6371000; // Earth's radius in meters
        const lat1 = coord1[1] * Math.PI / 180;
        const lat2 = coord2[1] * Math.PI / 180;
        const deltaLat = (coord2[1] - coord1[1]) * Math.PI / 180;
        const deltaLon = (coord2[0] - coord1[0]) * Math.PI / 180;

        const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                  Math.cos(lat1) * Math.cos(lat2) *
                  Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c;
    }

    formatTime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const remainingSeconds = Math.floor(seconds % 60);

        if (hours > 0) {
            return `${hours}h ${minutes}m ${remainingSeconds}s`;
        } else if (minutes > 0) {
            return `${minutes}m ${remainingSeconds}s`;
        } else {
            return `${remainingSeconds}s`;
        }
    }

    downloadGeoJSON(matchingData, fileName = null) {
        if (!matchingData) {
            throw new Error('No matched route data available. Please match a route first.');
        }

        const geoJsonData = {
            type: 'FeatureCollection',
            features: matchingData.features
        };

        this.downloadFile(
            JSON.stringify(geoJsonData, null, 2),
            'application/json',
            fileName || `matched-route-${new Date().toISOString().split('T')[0]}.geojson`
        );
    }

    downloadGPX(matchingData, originalFileName = null) {
        if (!matchingData) {
            throw new Error('No matched route data available. Please match a route first.');
        }

        const options = {
            creator: 'GPX Map Matching Tool',
            metadata: {
                name: `Matched Route - ${originalFileName || 'Unknown'}`,
                time: new Date()
            }
        };

        const gpxContent = window.togpx(matchingData, options);
        
        this.downloadFile(
            gpxContent,
            'application/gpx+xml',
            `matched-route-${new Date().toISOString().split('T')[0]}.gpx`
        );
    }

    downloadFile(content, mimeType, fileName) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = fileName;
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        URL.revokeObjectURL(url);
    }
}

if (typeof window !== 'undefined') {
    window.FileUtils = FileUtils;
} </script>
  <script type="module">const ROAD_COLORS = {
    'motorway': '#009933',
    'trunk': '#00cc99',
    'primary': '#009999',
    'secondary': '#00ccff',
    'tertiary': '#9999ff',
    'residential': '#9933ff',
    'service_other': '#ffcc66',
    'unclassified': '#666699'
};

const LAYER_STYLES = {
    GPS_TRACE_LINE: {
        'line-color': '#666666',
        'line-width': 4,
        'line-opacity': 0.8,
        'line-dasharray': [10, 5]
    },
    GPS_TRACE_POINTS: {
        'circle-radius': 4,
        'circle-color': '#000000',
        'circle-stroke-color': '#ffffff',
        'circle-stroke-width': 2,
        'circle-opacity': 0.9
    },
    MATCHED_TRACE_POINTS: {
        'circle-radius': 5,
        'circle-color': '#ffffff',
        'circle-stroke-color': '#007bff',
        'circle-stroke-width': 2,
        'circle-opacity': 0.9
    }
};

const MAP_CONFIG = {
    MAX_DISPLAY_POINTS: 50,
    BOUNDS_PADDING: 50
};

class MapMatchingMap {
    constructor(apiKey, defaultCenter, defaultZoom) {
        this.apiKey = apiKey;
        this.defaultCenter = defaultCenter;
        this.defaultZoom = defaultZoom;
        this.map = null;
        this.popup = null;
    }

    initialize(containerId) {
        this.map = new maplibregl.Map({
            container: containerId,
            style: `https://maps.geoapify.com/v1/styles/osm-bright/style.json?apiKey=${this.apiKey}`,
            center: this.defaultCenter,
            zoom: this.defaultZoom
        });

        this.map.addControl(new maplibregl.NavigationControl());

        return new Promise((resolve, reject) => {
            this.map.on('load', () => {
                try {
                    this.setupLayers();
                    this.setupPopup();
                    resolve(this.map);
                } catch (error) {
                    console.error('Error during map setup:', error);
                    reject(error);
                }
            });
            
            this.map.on('error', (error) => {
                console.error('Map error:', error);
                reject(error);
            });
        });
    }

    setupLayers() {
        this.map.addSource('gps-trace', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': []
            }
        });

        this.map.addLayer({
            'id': 'gps-trace-line',
            'type': 'line',
            'source': 'gps-trace',
            'paint': LAYER_STYLES.GPS_TRACE_LINE
        });

        this.map.addLayer({
            'id': 'gps-trace-points',
            'type': 'circle',
            'source': 'gps-trace',
            'filter': ['==', '$type', 'Point'],
            'paint': LAYER_STYLES.GPS_TRACE_POINTS
        });

        this.map.addSource('matched-trace', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': []
            }
        });

        this.map.addLayer({
            'id': 'matched-trace-line',
            'type': 'line',
            'source': 'matched-trace',
            'paint': {
                'line-color': this.createRoadColorExpression(),
                'line-width': 5,
                'line-opacity': 0.8
            }
        });

        this.map.addLayer({
            'id': 'matched-trace-points',
            'type': 'circle',
            'source': 'matched-trace',
            'filter': ['==', '$type', 'Point'],
            'paint': LAYER_STYLES.MATCHED_TRACE_POINTS
        });
    }

    createRoadColorExpression() {
        const expression = ['match', ['get', 'road_class']];
        
        Object.entries(ROAD_COLORS).forEach(([roadClass, color]) => {
            expression.push(roadClass, color);
        });
        
        expression.push('#007bff'); // default color
        return expression;
    }

    setupPopup() {
        this.popup = new maplibregl.Popup({
            closeButton: false,
            closeOnClick: false
        });

        this.map.on('mouseenter', 'matched-trace-line', (e) => {
            this.map.getCanvas().style.cursor = 'pointer';
            
            const properties = e.features[0].properties;
            const coords = e.lngLat;
            const roadClass = properties.road_class || 'unknown';
            const roadColor = ROAD_COLORS[roadClass] || '#007bff';
            
            this.popup.setLngLat(coords)
                .setHTML(this.createPopupContent(properties, roadClass, roadColor))
                .addTo(this.map);
        });

        this.map.on('mouseleave', 'matched-trace-line', () => {
            this.map.getCanvas().style.cursor = '';
            this.popup.remove();
        });
    }

    createPopupContent(properties, roadClass, roadColor) {
        return `
            <div class="popup-title">Road Information</div>
            ${properties.name ? `<div class="popup-info"><strong>Name:</strong> ${properties.name}</div>` : ''}
            <div class="popup-info"><strong>Road Class:</strong> <span style="color: ${roadColor}; font-weight: bold;">${roadClass}</span></div>
            ${properties.surface ? `<div class="popup-info"><strong>Surface:</strong> ${properties.surface}</div>` : ''}
            ${properties.speed_limit ? `<div class="popup-info"><strong>Speed Limit:</strong> ${properties.speed_limit} km/h</div>` : ''}
            ${properties.lane_count ? `<div class="popup-info"><strong>Lanes:</strong> ${properties.lane_count}</div>` : ''}
            ${properties.distance ? `<div class="popup-info"><strong>Distance:</strong> ${Math.round(properties.distance)} m</div>` : ''}
            ${properties.time ? `<div class="popup-info"><strong>Time:</strong> ${Math.round(properties.time)} s</div>` : ''}
        `;
    }

    displayGpsTrace(coordinates) {
        const lineFeature = {
            type: 'Feature',
            geometry: {
                type: 'LineString',
                coordinates: coordinates
            },
            properties: {}
        };

        const pointFeatures = this.createDisplayPoints(coordinates);

        this.map.getSource('gps-trace').setData({
            type: 'FeatureCollection',
            features: [lineFeature, ...pointFeatures]
        });

        this.fitBounds(coordinates);
    }

    createDisplayPoints(coordinates) {
        const pointFeatures = [];
        const step = Math.max(1, Math.floor(coordinates.length / MAP_CONFIG.MAX_DISPLAY_POINTS));
        
        for (let i = 0; i < coordinates.length; i += step) {
            pointFeatures.push({
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: coordinates[i]
                },
                properties: { type: 'gps-point' }
            });
        }

        if ((coordinates.length - 1) % step !== 0) {
            pointFeatures.push({
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: coordinates[coordinates.length - 1]
                },
                properties: { type: 'gps-point' }
            });
        }

        return pointFeatures;
    }

    displayMatchedTrace(matchingData) {
        const features = [];
        
        matchingData.features.forEach(feature => {
            if (feature.geometry.type === 'MultiLineString') {
                feature.properties.legs.forEach((leg, legIndex) => {
                    const legCoordinates = feature.geometry.coordinates[legIndex];
                    
                    leg.steps.forEach((step, stepIndex) => {
                        const stepCoordinates = legCoordinates.slice(step.from_index, step.to_index + 1);
                        
                        features.push({
                            type: 'Feature',
                            geometry: {
                                type: 'LineString',
                                coordinates: stepCoordinates
                            },
                            properties: step
                        });

                        if (stepIndex > 0) {
                            features.push({
                                type: 'Feature',
                                geometry: {
                                    type: 'Point',
                                    coordinates: stepCoordinates[0]
                                },
                                properties: step
                            });
                        }
                    });
                });
            }
        });

        this.map.getSource('matched-trace').setData({
            type: 'FeatureCollection',
            features: features
        });
    }

    clearDisplay() {
        if (this.map.getSource('gps-trace')) {
            this.map.getSource('gps-trace').setData({
                type: 'FeatureCollection',
                features: []
            });
        }

        if (this.map.getSource('matched-trace')) {
            this.map.getSource('matched-trace').setData({
                type: 'FeatureCollection',
                features: []
            });
        }
    }

    fitBounds(coordinates) {
        const bounds = new maplibregl.LngLatBounds();
        coordinates.forEach(coord => bounds.extend(coord));
        this.map.fitBounds(bounds, { padding: MAP_CONFIG.BOUNDS_PADDING });
    }

    resetView() {
        this.map.flyTo({
            center: this.defaultCenter,
            zoom: this.defaultZoom
        });
    }
}

if (typeof window !== 'undefined') {
    window.MapMatchingMap = MapMatchingMap;
} </script>
  <script type="module">const GEOAPIFY_API_KEY = '27a3c5f9a6754da28283d1995edb9467';
const DEFAULT_CENTER = [2.10, 48.81];
const DEFAULT_ZOOM = 3;
const MAX_POINTS = 1000;

const mapMatchingAPI = new MapMatchingAPI(GEOAPIFY_API_KEY);
const fileUtils = new FileUtils(MAX_POINTS);
const mapManager = new MapMatchingMap(GEOAPIFY_API_KEY, DEFAULT_CENTER, DEFAULT_ZOOM);

let currentGpxData = null;
let currentMatchingData = null;
let gpxFileName = null;

document.addEventListener('DOMContentLoaded', async function() {
    try {
        await initializeApp();
    } catch (error) {
        console.error('Failed to initialize app:', error);
    }
});

async function initializeApp() {
    await initializeMap();
    setupEventListeners();
}

async function initializeMap() {
    await mapManager.initialize('map');
    console.log('✅ Map Matching application initialized');
}

function setupEventListeners() {
    document.getElementById('upload-button').addEventListener('click', function() {
        document.getElementById('gpx-file-input').value = '';
        document.getElementById('gpx-file-input').click();
    });

    document.getElementById('gpx-file-input').addEventListener('change', handleFileUpload);
    document.getElementById('match-button').addEventListener('click', performMapMatching);
    document.getElementById('clear-all-button').addEventListener('click', clearAll);

    document.getElementById('error-ok-button').addEventListener('click', function() {
        hideErrorDialog();
    });

    document.getElementById('error-dialog').addEventListener('click', function(e) {
        if (e.target === e.currentTarget) {
            hideErrorDialog();
        }
    });

    document.getElementById('download-geojson').addEventListener('click', downloadGeoJSON);
    document.getElementById('download-gpx').addEventListener('click', downloadGPX);
}

async function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    if (!file.name.toLowerCase().endsWith('.gpx') && !file.name.toLowerCase().endsWith('.xml')) {
        showError('Please select a GPX file (.gpx or .xml)');
        return;
    }

    gpxFileName = file.name;
    const reader = new FileReader();
    
    reader.onload = function(e) {
        const gpxContent = e.target.result;
        parseGpxFile(gpxContent);
    };
    
    reader.onerror = function() {
        showError('Error reading file. Please try again.');
    };
    
    reader.readAsText(file);
}

function parseGpxFile(gpxContent) {
    try {
        const result = fileUtils.parseGpxFile(gpxContent);
        
        currentGpxData = result.gpxData;
        currentMatchingData = null;
        
        mapManager.clearDisplay();
        hideSummary();
        mapManager.displayGpsTrace(result.coordinates);
        
        if (result.simplificationApplied) {
            updateFileInfo(
                `${gpxFileName} - Route simplified from ${result.originalCount} to ${result.coordinates.length} points for optimal processing`,
                'success'
            );
        } else {
            updateFileInfo(
                `${gpxFileName} - ${result.coordinates.length} points loaded`,
                'success'
            );
        }

        document.getElementById('match-button').disabled = false;

    } catch (error) {
        console.error('Error parsing GPX file:', error);
        showError(`Error parsing GPX file: ${error.message}`);
    }
}

async function performMapMatching() {
    if (!currentGpxData || currentGpxData.length === 0) {
        showError('No GPS data available. Please upload a GPX file first.');
        return;
    }

    const travelModeElement = document.querySelector('input[name="travel-mode"]:checked');
    const travelMode = travelModeElement ? travelModeElement.value : 'walk';
    
    showLoadingIndicator();
    
    try {
        const matchingResult = await mapMatchingAPI.performMapMatching(currentGpxData, travelMode);
        
        currentMatchingData = matchingResult;
        
        mapManager.displayMatchedTrace(matchingResult);
        displaySummary(matchingResult, currentGpxData);

        console.log('✅ Map matching completed successfully');

    } catch (error) {
        console.error('❌ Error during map matching:', error);
        showError(`Map matching failed: ${error.message}`);
    } finally {
        hideLoadingIndicator();
    }
}

function displaySummary(matchingData, currentGpxData) {
    let totalDistance = 0;
    let totalTime = 0;
    let originalDistance = 0;

    matchingData.features.forEach(feature => {
        if (feature.properties.legs) {
            feature.properties.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    totalDistance += step.distance || 0;
                    totalTime += step.time || 0;
                });
            });
        }
    });

    if (currentGpxData && currentGpxData.length > 1) {
        for (let i = 0; i < currentGpxData.length - 1; i++) {
            const coord1 = currentGpxData[i].location;
            const coord2 = currentGpxData[i + 1].location;
            originalDistance += fileUtils.calculateHaversineDistance(coord1, coord2);
        }
    }

    const travelModeElement = document.querySelector('input[name="travel-mode"]:checked');
    const travelMode = travelModeElement ? travelModeElement.value : 'unknown';

    const summaryContent = `
        <div class="summary-item">
            <span class="summary-label">Original Points:</span>
            <span class="summary-value">${currentGpxData.length}</span>
        </div>
        <div class="summary-item">
            <span class="summary-label">Original Distance:</span>
            <span class="summary-value">${(originalDistance / 1000).toFixed(2)} km</span>
        </div>
        <div class="summary-item">
            <span class="summary-label">Matched Distance:</span>
            <span class="summary-value">${(totalDistance / 1000).toFixed(2)} km</span>
        </div>
        <div class="summary-item">
            <span class="summary-label">Estimated Time:</span>
            <span class="summary-value">${fileUtils.formatTime(totalTime)}</span>
        </div>
        <div class="summary-item">
            <span class="summary-label">Travel Mode:</span>
            <span class="summary-value">${travelMode}</span>
        </div>
    `;

    document.getElementById('summary-content').innerHTML = summaryContent;
    document.getElementById('summary-info').classList.remove('hidden');
    document.getElementById('download-section').classList.remove('hidden');
}

function clearAll() {
    currentGpxData = null;
    currentMatchingData = null;
    gpxFileName = null;

    mapManager.clearDisplay();
    hideSummary();
    hideFileInfo();
    document.getElementById('gpx-file-input').value = '';
    document.getElementById('match-button').disabled = true;

    mapManager.resetView();
}

function downloadGeoJSON() {
    try {
        fileUtils.downloadGeoJSON(currentMatchingData);
    } catch (error) {
        console.error('Error downloading GeoJSON:', error);
        showError(error.message);
    }
}

function downloadGPX() {
    try {
        fileUtils.downloadGPX(currentMatchingData, gpxFileName);
    } catch (error) {
        console.error('Error downloading GPX:', error);
        showError('Error creating GPX file. Please try again.');
    }
}

function updateFileInfo(message, type = 'info') {
    const fileInfo = document.getElementById('file-info');
    if (fileInfo) {
        fileInfo.textContent = message;
        fileInfo.className = `file-info ${type}`;
        fileInfo.classList.remove('hidden');
    }
}

function hideFileInfo() {
    const fileInfo = document.getElementById('file-info');
    if (fileInfo) {
        fileInfo.classList.add('hidden');
    }
}

function showError(message) {
    const errorMessage = document.getElementById('error-message');
    const errorDialog = document.getElementById('error-dialog');
    
    if (errorMessage && errorDialog) {
        errorMessage.textContent = message;
        errorDialog.classList.remove('hidden');
    }
}

function hideErrorDialog() {
    const errorDialog = document.getElementById('error-dialog');
    if (errorDialog) {
        errorDialog.classList.add('hidden');
    }
}

function showLoadingIndicator() {
    const loadingIndicator = document.getElementById('loading-indicator');
    if (loadingIndicator) {
        loadingIndicator.classList.remove('hidden');
    }
}

function hideLoadingIndicator() {
    const loadingIndicator = document.getElementById('loading-indicator');
    if (loadingIndicator) {
        loadingIndicator.classList.add('hidden');
    }
}

function hideSummary() {
    const summaryInfoElement = document.getElementById('summary-info');
    const downloadSectionElement = document.getElementById('download-section');

    if (summaryInfoElement) {
        summaryInfoElement.classList.add('hidden');
    }

    if (downloadSectionElement) {
        downloadSectionElement.classList.add('hidden');
    }
} </script>
</body>

</html> 